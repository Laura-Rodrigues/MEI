(*

This exercise is based on a model of an emailing system. The system
is modeled through two state variables, "sent" (a set of messages) and
"inbox" (a dictionary mapping users to sets of messages - individual
inboxes). The overall goal is to complete the *specifications* of the
two functions "send" and "receive", so that the type invariant
provided is respected, and also the execution functions scenario1 and
scenario2 can be fully verified. Scenario3 should not be fully
verified, as it contains an error - it plays the role of a sanity
check.

You should write adequate preconditions and postconditions for "send"
and "receive". If required, feel free to strengthen the type
invariant, including additional information. All the verification
conditions generated should be provable in the TryWhy3 platform, with
the exception of some VCs generated for Scenario3. 

*)



module Email

  use int.Int

  type user 
  type content
  type message = { from : user;
       	       	   tto : user; 
                   content : content }

  clone set.SetApp with type elt = message

  clone fmap.MapApp with type key = user 


  type statetype = { mutable sent : set ; mutable inbox : t set }
    invariant { (forall u :user, m :message. mem u inbox /\ SetApp.mem m (inbox u) -> m.tto = u) 
            /\ 
        (*    (forall m :message. SetApp.mem m sent -> not SetApp.mem m (find m.tto inbox))
            /\
            (forall m :message. SetApp.mem m (find m.tto inbox) -> not SetApp.mem m sent)
        *) true
            }
    by { sent = empty() ; inbox = create() }


  val state : statetype





  let send (f t :user) (c :content) : () 
    (*  Para poder enviar msgs tem que ter uma inbox
        A msg não pode já ter sido enviada *)
    requires { mem t state.inbox } 
    requires { let m = { from=f ; tto=t ; content=c } in not SetApp.mem m state.sent}
    
    (*  O destinatrio continua a ter inbox
        A msg foi enviada 
        O número de msgs enviadas aumenta *)
    ensures { mem t state.inbox } 
    ensures { let m = { from=f ; tto=t ; content=c } in SetApp.mem m state.sent}
    ensures { cardinal state.sent = cardinal (old state.sent) + 1 }

    (* O conjunto de mensagens enviadas continua igual, mas com uma mensagem nova *) 
    ensures  { forall m :message. SetApp.mem m state.sent <-> SetApp.mem m (old state.sent) \/ m = { from=f ; tto=t ; content=c }  }
 
    writes   { state.sent }
  = let m = { from=f ; tto=t ; content=c } in 
    state.sent <- SetApp.add m state.sent




  let receive (t :user) (m :message) : ()
    (*  A mensagem recebida tem que estar no conjunto das msgs enviadas
        Para poder receber msgs tem que ter uma inbox 
        O destinatário de m:message é t:user *)
    requires { SetApp.mem m state.sent }
    requires { mem t state.inbox } 
    requires { m.tto = t }
    
    (*  A msg passa a ser membro do conjunto inbox o user
        A msg deixa de estar no conjunto das enviadas 
        O número de msgs enviadas diminui 
        Se um user já tinha uma inbox associada continua a ter *)
    ensures { SetApp.mem m (state.inbox t) }
    ensures { not SetApp.mem m state.sent }
    ensures { cardinal (state.sent) = cardinal (old state.sent) - 1 }
    ensures { forall u :user. mem u (old state.inbox) <-> mem u state.inbox }


    (* Uma mensagem é recebida se e só se tiver sido recebida antes ou for a mensagem e o destinatário passados como argumento *)
    ensures { forall u :user, ms: message. mem u state.inbox /\ SetApp.mem ms (state.inbox u) <-> (mem u (old state.inbox) /\ SetApp.mem ms ((old state.inbox) u)) \/ (t = u /\ m = ms) }


    (* Uma mensagem faz parte de sent sse fizer parte antes da execução e não for a mensagem a enviar *)
    ensures { forall ms :message. ms <> m /\ SetApp.mem ms (old state.sent) <-> SetApp.mem ms state.sent }
    
    
    writes   { state.sent, state.inbox }
  = let umsgs = SetApp.add m (find t state.inbox) in
    state.inbox <- add t umsgs state.inbox;
    state.sent <- SetApp.remove m state.sent




  val u :user
  val f :user
  val t :user
  val c :content


  let scenario1 ()
    requires { let m = { from=u ; tto=u ; content=c }  in not SetApp.mem m state.sent }
    requires { mem u state.inbox }
    ensures  { cardinal (state.sent) = cardinal (old state.sent) }
  = send u u c ; receive u { from=u ; tto=u ; content=c } 


  let scenario2 ()
    requires { SetApp.is_empty(state.sent) }
    requires { mem u state.inbox }
    requires { mem t state.inbox }
    requires { u<>t }        
    ensures  { SetApp.is_empty(state.sent) }
  = send f u c ; send f t c ; receive u { from=f ; tto=u ; content=c } ; receive t { from=f ; tto=t ; content=c } 


  (* FAIL - checks inconsistencies *)
  let scenario3 ()  
    requires { let m = { from=u ; tto=u ; content=c } in not SetApp.mem m state.sent }
    requires { mem u state.inbox }
    ensures  { cardinal (state.sent) = cardinal (old state.sent) }
  = send u u c ; receive u { from=f ; tto=u ; content=c } 




end



