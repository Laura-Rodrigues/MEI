

module Bintree_insert

  use  int.Int


  type tree 'a = Empty | Node (tree 'a) 'a (tree 'a)
                                     
  function size (t: tree 'a) : int =
   (* ensures { result >= 0 } *)
  match t with
  |  Empty -> 0
  |  Node l _ r -> 1 + (size l) + (size r)
  end
                                     
  predicate memt (t : tree int) (k : int) =
  match t with
  | Empty -> false
  | Node t1 x t2 -> (k = x) \/ memt t1 k \/ memt t2 k
  end


  (* predicate geq_tree (x : int) (t : tree int) = *)
  (*   forall k : int. memt t k -> x >= k *)

  let rec predicate geq_tree (x : int) (t : tree int)
    ensures { result <-> forall k : int. not (memt t k) \/ x >= k }
  = match t with
    | Empty -> true
    | Node t1 k t2 -> k <= x && geq_tree x t1 && geq_tree x t2
    end

  (* predicate leq_tree (x : int) (t : tree int) = *)
  (*   forall k : int. memt t k -> x <= k *)

  let rec predicate leq_tree (x : int) (t : tree int)
    ensures { result <-> forall k : int. not (memt t k) \/ x <= k }
  = match t with
    | Empty -> true
    | Node t1 k t2 -> x <= k && leq_tree x t1 && leq_tree x t2
    end

  predicate sortedBT (t : tree int) =
  match t with
  | Empty -> true
  | Node t1 x t2 -> sortedBT t1 /\ sortedBT t2 /\
                    geq_tree x t1 /\ leq_tree x t2
  end


  function num_occ (x: 'a) (t: tree 'a) : int =
  match t with
  | Empty -> 0
  | Node t1 y t2 -> (if x = y then 1 else 0) + num_occ x t1 + num_occ x t2
  end




  let rec function add (t : tree int) (v : int) : tree int =
    requires { sortedBT t }
    ensures  { sortedBT result }
    ensures  { size result = size t + 1 } 
    ensures  { forall x : int. memt result x <-> (memt t x \/ x = v) }
    ensures  { forall x : int. num_occ x result =
                               if x = v then 1 + num_occ x t else num_occ x t }
    (* variant { t } *)
    match t with
     | Empty -> Node (Empty) v (Empty)
     | Node t1 x t2 ->
       if v <= x then Node (add t1 v) x t2 else Node t1 x (add t2 v)
    end



               
end

